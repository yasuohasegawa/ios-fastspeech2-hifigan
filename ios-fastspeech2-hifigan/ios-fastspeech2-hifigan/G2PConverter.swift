//
//  G2PConverter.swift
//  OpenJTalkForiOS
//
//  Created by Yasuo Hasegawa on 2025/07/13.
//

import Foundation

// This code generated by gemini
// We tweaked the normalize part.
class G2PConverter {
    private let cmuDict: CMUDict
    private(set) var customPronunciations: [String: [String]] = [:]
    private let letterPronunciations: [Character: [String]] = [
        "A": ["EY1"],         "B": ["B", "IY1"],    "C": ["S", "IY1"],
        "D": ["D", "IY1"],    "E": ["IY1"],         "F": ["EH1", "F"],
        "G": ["JH", "IY1"],   "H": ["EY1", "CH"],   "I": ["AY1"],
        "J": ["JH", "EY1"],   "K": ["K", "EY1"],    "L": ["EH1", "L"],
        "M": ["EH1", "M"],    "N": ["EH1", "N"],    "O": ["OW1"],
        "P": ["P", "IY1"],    "Q": ["K", "Y", "UW1"], "R": ["AA1", "R"],
        "S": ["EH1", "S"],    "T": ["T", "IY1"],    "U": ["Y", "UW1"],
        "V": ["V", "IY1"],    "W": ["D", "AH1", "B", "AH0", "L", "Y", "UW1"],
        "X": ["EH1", "K", "S"], "Y": ["W", "AY1"],    "Z": ["Z", "IY1"]
    ]
    
    private let numberFormatter: NumberFormatter = {
        let formatter = NumberFormatter()
        formatter.numberStyle = .spellOut
        return formatter
    }()
    
    init() {
        do {
            self.cmuDict = try CMUDict()
        } catch {
            fatalError("Could not initialize G2PConverter: \(error)")
        }
    }

    func addCustomPronunciation(for word: String, phonemes: [String]) {
            customPronunciations[word.uppercased()] = phonemes
    }
    
    func loadCustomPronunciations(from dictionary: [String: [String]]) {
        self.customPronunciations = Dictionary(uniqueKeysWithValues: dictionary.map { ($0.key.uppercased(), $0.value) })
    }
    
    func clearCustomPronunciations() {
        customPronunciations.removeAll()
    }
    
    func normalize(text: String) -> String {
        let pattern = #"(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])"#
        let result = text.replacingOccurrences(of: pattern, with: " ", options: .regularExpression)
        //print(">>>>> normalize:\(result)")
        return result
    }
    
    func convert(text: String) -> [String] {
        let normalizedText = normalize(text: text)
        let cleanedText = normalizedText.uppercased()
        
        let tokens = cleanedText.matches(for: "[A-Z']+|\\d+|[^A-Z'\\d\\s]")
        
        return tokens.flatMap { getPhonemes(forToken: $0) }
    }
    
    private func getPhonemes(forToken token: String) -> [String] {
        if let customPhonemes = customPronunciations[token] {
            return customPhonemes
        }
        
        if let cmuPhonemes = cmuDict.getPhonemes(for: token) {
            return cmuPhonemes
        }
        
        if let number = Int(token) {
            if let spelledOut = numberFormatter.string(from: NSNumber(value: number)) {
                print("✅ Number detected: '\(token)'. Verbalizing as: '\(spelledOut.uppercased())'")
                return convert(text: spelledOut)
            }
        }
        
        if token.allSatisfy({ $0.isASCII && $0.isUppercase }) && (2...5).contains(token.count) {
            print("✅ Acronym detected: '\(token)'. Pronouncing letter names.")
            // Use flatMap to process each letter and add spaces in between.
            return token.enumerated().flatMap { (index, letter) -> [String] in
                var phonemes = letterPronunciations[letter] ?? [String(letter)]
                if index < token.count - 1 {
                    phonemes.append(" ") // Add space between letters
                }
                return phonemes
            }
        }

        if token.allSatisfy({ $0.isLetter }) {
            print("⚠️ OOV word detected: '\(token)'. Spelling it out.")
            return token.map { String($0) }
        }
        
        return [token]
    }
}
